#include "mat4.h"
#include <math.h>

void Mat4::setToIdentity()
{
    m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = 0.0;
    m[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = 0.0;
    m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = 0.0;
    m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;
}

void Mat4::rotateZ(float deg)
{
    double rad = deg * M_PI / 180;
	float sine = (float) sin(rad );
	float cose = (float) cos (rad);
	Mat4 rm;
	rm.m[0][0] = cose; rm.m[0][1] = sine; rm.m[0][2] =0.; rm.m[0][3] =0.;
	rm.m[1][0] = -sine; rm.m[1][1] = cose; rm.m[1][2] =0.; rm.m[1][3] =0.;
	rm.m[2][0] = 0.0; rm.m[2][1] = 0.; rm.m[2][2] =1.; rm.m[2][3] =0.;
    rm.m[3][0] = 0.0; rm.m[3][1] = 0.; rm.m[3][2] =0.; rm.m[3][3] =1.;
	(*this)*= rm;

}

Mat4 &Mat4::operator*=(const Mat4 &other)
{
	float m0, m1, m2;
	m0 = m[0][0] * other.m[0][0]
			+ m[1][0] * other.m[0][1]
			+ m[2][0] * other.m[0][2]
			+ m[3][0] * other.m[0][3];
	m1 = m[0][0] * other.m[1][0]
			+ m[1][0] * other.m[1][1]
			+ m[2][0] * other.m[1][2]
			+ m[3][0] * other.m[1][3];
	m2 = m[0][0] * other.m[2][0]
			+ m[1][0] * other.m[2][1]
			+ m[2][0] * other.m[2][2]
			+ m[3][0] * other.m[2][3];
	m[3][0] = m[0][0] * other.m[3][0]
			+ m[1][0] * other.m[3][1]
			+ m[2][0] * other.m[3][2]
			+ m[3][0] * other.m[3][3];
	m[0][0] = m0;
	m[1][0] = m1;
	m[2][0] = m2;

	m0 = m[0][1] * other.m[0][0]
			+ m[1][1] * other.m[0][1]
			+ m[2][1] * other.m[0][2]
			+ m[3][1] * other.m[0][3];
	m1 = m[0][1] * other.m[1][0]
			+ m[1][1] * other.m[1][1]
			+ m[2][1] * other.m[1][2]
			+ m[3][1] * other.m[1][3];
	m2 = m[0][1] * other.m[2][0]
			+ m[1][1] * other.m[2][1]
			+ m[2][1] * other.m[2][2]
			+ m[3][1] * other.m[2][3];
	m[3][1] = m[0][1] * other.m[3][0]
			+ m[1][1] * other.m[3][1]
			+ m[2][1] * other.m[3][2]
			+ m[3][1] * other.m[3][3];
	m[0][1] = m0;
	m[1][1] = m1;
	m[2][1] = m2;

	m0 = m[0][2] * other.m[0][0]
			+ m[1][2] * other.m[0][1]
			+ m[2][2] * other.m[0][2]
			+ m[3][2] * other.m[0][3];
	m1 = m[0][2] * other.m[1][0]
			+ m[1][2] * other.m[1][1]
			+ m[2][2] * other.m[1][2]
			+ m[3][2] * other.m[1][3];
	m2 = m[0][2] * other.m[2][0]
			+ m[1][2] * other.m[2][1]
			+ m[2][2] * other.m[2][2]
			+ m[3][2] * other.m[2][3];
	m[3][2] = m[0][2] * other.m[3][0]
			+ m[1][2] * other.m[3][1]
			+ m[2][2] * other.m[3][2]
			+ m[3][2] * other.m[3][3];
	m[0][2] = m0;
	m[1][2] = m1;
	m[2][2] = m2;

	m0 = m[0][3] * other.m[0][0]
			+ m[1][3] * other.m[0][1]
			+ m[2][3] * other.m[0][2]
			+ m[3][3] * other.m[0][3];
	m1 = m[0][3] * other.m[1][0]
			+ m[1][3] * other.m[1][1]
			+ m[2][3] * other.m[1][2]
			+ m[3][3] * other.m[1][3];
	m2 = m[0][3] * other.m[2][0]
			+ m[1][3] * other.m[2][1]
			+ m[2][3] * other.m[2][2]
			+ m[3][3] * other.m[2][3];
	m[3][3] = m[0][3] * other.m[3][0]
			+ m[1][3] * other.m[3][1]
			+ m[2][3] * other.m[3][2]
			+ m[3][3] * other.m[3][3];
	m[0][3] = m0;
	m[1][3] = m1;
	m[2][3] = m2;
	return *this;
}

Mat4::Mat4()
{
    setToIdentity();
}

Mat4::Mat4(float _scale)
{
    m[0][0] = _scale; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = 0.0;
    m[1][0] = 0.0; m[1][1] = _scale; m[1][2] = 0.0; m[1][3] = 0.0;
    m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = 0.0;
    m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;
}

void Mat4::translate(Point &p)
{
	translate(p.x, p.y, p.z);
}

void Mat4::translate(float x, float y, float z)
{
	m[3][0] = m[3][0] + x;
	m[3][1] = m[3][1] + y;
    m[3][2] = m[3][2] + z;
}

void Mat4::scale(float x, float y, float z)
{
    m[0][0] = m[0][0] * x;
    m[1][1] = m[1][1] * y;
    m[2][2] = m[2][2] * z;

}
void Mat4::scale(Point &p)
{
    scale(p.x, p.y, p.z);
}

Mat4 operator * (const Mat4 &m1, const Mat4 &m2)
{
	Mat4 m;
	m.m[0][0] = m1.m[0][0] * m2.m[0][0]
			  + m1.m[1][0] * m2.m[0][1]
			  + m1.m[2][0] * m2.m[0][2]
			  + m1.m[3][0] * m2.m[0][3];
	m.m[0][1] = m1.m[0][1] * m2.m[0][0]
			  + m1.m[1][1] * m2.m[0][1]
			  + m1.m[2][1] * m2.m[0][2]
			  + m1.m[3][1] * m2.m[0][3];
	m.m[0][2] = m1.m[0][2] * m2.m[0][0]
			  + m1.m[1][2] * m2.m[0][1]
			  + m1.m[2][2] * m2.m[0][2]
			  + m1.m[3][2] * m2.m[0][3];
	m.m[0][3] = m1.m[0][3] * m2.m[0][0]
			  + m1.m[1][3] * m2.m[0][1]
			  + m1.m[2][3] * m2.m[0][2]
			  + m1.m[3][3] * m2.m[0][3];

	m.m[1][0] = m1.m[0][0] * m2.m[1][0]
			  + m1.m[1][0] * m2.m[1][1]
			  + m1.m[2][0] * m2.m[1][2]
			  + m1.m[3][0] * m2.m[1][3];
	m.m[1][1] = m1.m[0][1] * m2.m[1][0]
			  + m1.m[1][1] * m2.m[1][1]
			  + m1.m[2][1] * m2.m[1][2]
			  + m1.m[3][1] * m2.m[1][3];
	m.m[1][2] = m1.m[0][2] * m2.m[1][0]
			  + m1.m[1][2] * m2.m[1][1]
			  + m1.m[2][2] * m2.m[1][2]
			  + m1.m[3][2] * m2.m[1][3];
	m.m[1][3] = m1.m[0][3] * m2.m[1][0]
			  + m1.m[1][3] * m2.m[1][1]
			  + m1.m[2][3] * m2.m[1][2]
			  + m1.m[3][3] * m2.m[1][3];

	m.m[2][0] = m1.m[0][0] * m2.m[2][0]
			  + m1.m[1][0] * m2.m[2][1]
			  + m1.m[2][0] * m2.m[2][2]
			  + m1.m[3][0] * m2.m[2][3];
	m.m[2][1] = m1.m[0][1] * m2.m[2][0]
			  + m1.m[1][1] * m2.m[2][1]
			  + m1.m[2][1] * m2.m[2][2]
			  + m1.m[3][1] * m2.m[2][3];
	m.m[2][2] = m1.m[0][2] * m2.m[2][0]
			  + m1.m[1][2] * m2.m[2][1]
			  + m1.m[2][2] * m2.m[2][2]
			  + m1.m[3][2] * m2.m[2][3];
	m.m[2][3] = m1.m[0][3] * m2.m[2][0]
			  + m1.m[1][3] * m2.m[2][1]
			  + m1.m[2][3] * m2.m[2][2]
			  + m1.m[3][3] * m2.m[2][3];

	m.m[3][0] = m1.m[0][0] * m2.m[3][0]
			  + m1.m[1][0] * m2.m[3][1]
			  + m1.m[2][0] * m2.m[3][2]
			  + m1.m[3][0] * m2.m[3][3];
	m.m[3][1] = m1.m[0][1] * m2.m[3][0]
			  + m1.m[1][1] * m2.m[3][1]
			  + m1.m[2][1] * m2.m[3][2]
			  + m1.m[3][1] * m2.m[3][3];
	m.m[3][2] = m1.m[0][2] * m2.m[3][0]
			  + m1.m[1][2] * m2.m[3][1]
			  + m1.m[2][2] * m2.m[3][2]
			  + m1.m[3][2] * m2.m[3][3];
	m.m[3][3] = m1.m[0][3] * m2.m[3][0]
			  + m1.m[1][3] * m2.m[3][1]
			  + m1.m[2][3] * m2.m[3][2]
			  + m1.m[3][3] * m2.m[3][3];
	return m;
}
